package main

import (
	"fmt"
	"log"
	"os"
	"sort"
	"strconv"
	"strings"
	"unicode"
)

type KeyValue struct {
	Key   string
	Value string
}
type Master struct {
	// Your definitions here.
	mapF            func(filename, content string) []KeyValue
	reduceF         func(key string, values []string) string
	NoOfReduceTasks int
	mappedFiles     []string
}
type ByKey []KeyValue

func (a ByKey) Len() int           { return len(a) }
func (a ByKey) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByKey) Less(i, j int) bool { return a[i].Key < a[j].Key }

func Map(filename string, contents string) []KeyValue {
	// function to detect word separators.
	ff := func(r rune) bool { return !unicode.IsLetter(r) }

	// split contents into an array of words.
	words := strings.FieldsFunc(contents, ff)

	kva := []KeyValue{}
	for _, w := range words {
		kv := KeyValue{w, "1"}
		kva = append(kva, kv)
	}
	return kva
}
func Sequential(files []string, nReduce int, mapFunc func(filename, content string) []KeyValue, reduceFunc func(key string, values []string) string) {

	intermediateOutputs := make([]KeyValue, 0)
	for _, file := range files {
		f, err := os.Open(file)
		if err != nil {
			log.Printf("could not open file %s", file)
		}
		info, err := f.Stat()
		if err != nil {
			log.Printf("could not get file %s info", file)
		}

		contents := make([]byte, info.Size())
		f.Read(contents)
		f.Close()
		kv := mapFunc(file, string(contents))
		intermediateOutputs = append(intermediateOutputs, kv...)
	}

	sort.Sort(ByKey(intermediateOutputs))
	outputFileName := "mr-out"
	outFile, err := os.Create(outputFileName)
	if err != nil {
		log.Printf("could not create output file")
	}
	i := 0
	for i < len(intermediateOutputs) {
		j := i + 1

		for j < len(intermediateOutputs) && intermediateOutputs[i].Key == intermediateOutputs[j].Key {
			j++
		}
		values := make([]string, 0)
		for k := i; k < j; k++ {
			values = append(values, intermediateOutputs[k].Value)
		}
		output := reduceFunc(intermediateOutputs[i].Key, values)
		fmt.Fprintf(outFile, "%v %v\n", intermediateOutputs[i].Key, output)
		i = j
	}
	outFile.Close()
}

// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
func Reduce(key string, values []string) string {
	// return the number of occurrences of this word.
	return strconv.Itoa(len(values))
}

func main() {
	Sequential([]string{"go.mod"}, 2, Map, Reduce)
}
